<!DOCTYPE html>
<html lang="zh-Hant">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>Tag 455667 Chess</title>

    <link rel="manifest" href="./manifest.json">
    <link rel="apple-touch-icon" href="./icon.png">
    <meta name="theme-color" content="#000000">

    <meta name="apple-mobile-web-app-capable" content="yes">
    <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
    <meta name="apple-mobile-web-app-title" content="Tag 455667">
    
    <script src="https://cdn.tailwindcss.com"></script>
    <script crossorigin src="https://unpkg.com/react@18.2.0/umd/react.production.min.js"></script>
    <script crossorigin src="https://unpkg.com/react-dom@18.2.0/umd/react-dom.production.min.js"></script>
    <script src="https://unpkg.com/@babel/standalone/babel.min.js"></script>
    
    <style>
        body {
            -webkit-touch-callout: none;
            -webkit-user-select: none;
            user-select: none;
            touch-action: manipulation;
            background-color: #000000;
            overscroll-behavior-y: none; 
            padding-bottom: env(safe-area-inset-bottom);
        }
    </style>
</head>
<body>
    <div id="root"></div>

    <script type="text/babel">
        const { useState, useEffect, useRef, useCallback } = React;

        const SAVE_KEY = "tag_455667_chess_save_v2_renamed";

        const THEME_COLORS = {
            PURPLE: '#6a0dad',      // User, é­”çœ¼, çµç•Œ
            RED: '#D72600',         // AI Red, æ”»æ“Š
            YELLOW: '#ECD407',      // AI Yellow, è§£éŽ–
            GREEN: '#379711',       // AI Green, æ²»ç™‚
            
            DAMAGE: '#D72600',      // ç´…è‰²é–ƒå…‰
            BLUE: '#0956BF',        // è­·ç›¾, æ²™æ¼
            UNLOCK: '#ECD407',      // é»ƒè‰²é–ƒå…‰
            HEAL: '#379711',        // ç¶ è‰²é–ƒå…‰
            GRAY: '#6b7280',        // ç„¡æ•ˆ
            
            BROWN_DARK: '#3e2723',  // é‚Šæ¡†
            BROWN_LIGHT: '#8d6e63', // ç·šæ¢
            PAPER_BEIGE: '#f5f5dc', // ç´™å¼µ
            BLACK: '#000000',       // èƒŒæ™¯
            GOLD: '#FFD700',        // å‹åˆ©
            STONE_300: '#d6d3d1',
            SLATE_400: '#94a3b8',
            BG_DARK: '#0c0a09',
            BG_PANEL: '#1c1917',
            BROWN_MID: '#8d6e63'
        };

        const COLORS = {
            purple: THEME_COLORS.PURPLE, 
            red: THEME_COLORS.RED,        
            yellow: THEME_COLORS.YELLOW, 
            green: THEME_COLORS.GREEN    
        };

        const ICON_PATHS = {
            Shield: "M12 22s8-4 8-10V5l-8-3-8 3v7c0 6 8 10 8 10z",
            Swords: "M14.5 17.5 L3 6 V3 H6 L17.5 14.5 Z M13 19 L19 13 M16 16 L20 20 M19 21 L21 19 M6.5 14.5 L18 3 H21 V6 L9.5 17.5 Z M5 13 L11 19 M8 16 L4 20 M3 19 L5 21",
            SwordFull: "M14.5 17.5 L3 6 V3 H6 L17.5 14.5 M13 19 L19 13 M16 16 L20 20 M19 21 L21 19", 
            Move: "M5 9l-3 3 3 3 M9 5l3-3 3 3 M19 9l3 3-3 3 M15 19l-3 3-3-3 M2 12h20 M12 2v20",
            Lock: "M5 11h14a2 2 0 0 1 2 2v7a2 2 0 0 1-2 2H5a2 2 0 0 1-2-2v-7a2 2 0 0 1 10 0v4 M12 16v3",
            Eye: "M2 12s3-7 10-7 10 7 10 7-3 7-10 7-10-7-10-7Z M12 15a3 3 0 1 0 0-6 3 3 0 0 0 0 6Z",
            RotateCcw: "M3 12a9 9 0 1 0 9-9 9.75 9.75 0 0 0-6.74 2.74L3 8 M3 3v5h5",
            Heart: "M19 14c1.49-1.46 3-3.21 3-5.5A5.5 5.5 0 0 0 16.5 3c-1.76 0-3 .5-4.5 2-1.5-1.5-2.74-2-4.5-2A5.5 5.5 0 0 0 2 8.5c0 2.3 1.5 4.05 3 5.5l7 7Z",
            User: "M19 21v-2a4 4 0 0 0-4-4H9a4 4 0 0 0-4 4v2 M12 13a4 4 0 1 0 0-8 4 4 0 0 0 0 8Z",
            HelpCircle: "M12 22a10 10 0 1 0 0-20 10 10 0 0 0 0 20z M9.09 9a3 3 0 0 1 5.83 1c0 2-3 3-3 3 M12 17h.01",
            Archive: "M21 8v13H3V8 M1 3h22v5H1z M10 12h4",
            Layers: "M12 2L2 7l10 5 10-5-10-5z M2 17l10 5 10-5 M2 12l10 5 10-5",
            Check: "M20 6L9 17l-5-5",
            Zap: "M13 2L3 14h9l-1 8 10-12h-9l1-8z",
            Target: "M12 22a10 10 0 1 0 0-20 10 10 0 0 0 0 20z M12 18a6 6 0 1 0 0-12 6 6 0 0 0 0 12z M12 14a2 2 0 1 0 0-4 2 2 0 0 0 0 4z",
            X: "M18 6L6 18 M6 6l12 12",
            ShieldCheck: "M12 22s8-4 8-10V5l-8-3-8 3v7c0 6 8 10 8 10z M9 12l2 2 4-4",
            List: "M8 6h13 M8 12h13 M8 18h13 M3 6h.01 M3 12h.01 M3 18h.01",
            Key: "M21 2l-2 2m-7.61 7.61a5.5 5.5 0 1 1-7.778 7.778 5.5 5.5 0 0 1 7.777-7.777zm0 0L15.5 7.5m0 0l3 3L22 7l-3-3m-3.5 3.5L19 4",
            Skull: "M7 21a2 2 0 0 1-2-2V9a7 7 0 0 1 14 0v10a2 2 0 0 1-2 2 M9 13a1 1 0 1 1-2 0 M17 13a1 1 0 1 1-2 0",
            ArrowUpDown: "M12 3v18 M16 7l-4-4-4 4 M8 17l4 4 4-4",
            ArrowLeftRight: "M3 12h18 M7 8l-4 4 4 4 M17 16l4-4-4-4",
            Flame: "M8.5 14.5A2.5 2.5 0 0 0 11 12c0-1.38-.5-2-1-3-1.072-2.143-.224-4.054 2-6 .5 2.5 2 4.9 4 6.5 2 1.6 3 3.5 3 5.5a7 7 0 1 1-14 0c0-1.1.2-2.2.6-3.3.7.8 1.9 1.8 3 1.8z",
            Hourglass: "M5 22h14 M5 2h14 M17 22v-4.172a2 2 0 0 0-.586-1.414L12 12l-4.414 4.414A2 2 0 0 0 7 17.828V22 M7 2v4.172a2 2 0 0 0 .586 1.414L12 12l4.414-4.414A2 2 0 0 0 17 6.172V2",
            Moon: "M12 3a6 6 0 0 0 9 9 9 9 0 1 1-9-9Z",
            RefreshCw: "M3 12a9 9 0 0 1 9-9 9.75 9.75 0 0 1 6.74 2.74L21 8 M21 3v5h-5 M21 12a9 9 0 0 1-9 9 9.75 9.75 0 0 1-6.74-2.74L3 16 M3 21v-5h5"
        };

        const IconBase = ({ name, size = 24, className = "", style = {}, ...props }) => {
            const pathData = ICON_PATHS[name];
            if (!pathData) return null;
            return <svg xmlns="http://www.w3.org/2000/svg" width={size} height={size} viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round" className={className} style={style} {...props}><path d={pathData} /></svg>;
        };

        const Shield = (props) => <IconBase name="Shield" {...props} />;
        const Swords = (props) => <IconBase name="Swords" {...props} />;
        const Sword = (props) => <IconBase name="SwordFull" {...props} />;
        const Move = (props) => <IconBase name="Move" {...props} />;
        const Lock = (props) => <IconBase name="Lock" {...props} />;
        const Eye = (props) => <IconBase name="Eye" {...props} />;
        const RotateCcw = (props) => <IconBase name="RotateCcw" {...props} />;
        const Heart = (props) => <IconBase name="Heart" {...props} />;
        const User = (props) => <IconBase name="User" {...props} />;
        const HelpCircle = (props) => <IconBase name="HelpCircle" {...props} />;
        const Archive = (props) => <IconBase name="Archive" {...props} />;
        const Layers = (props) => <IconBase name="Layers" {...props} />;
        const Check = (props) => <IconBase name="Check" {...props} />;
        const Zap = (props) => <IconBase name="Zap" {...props} />;
        const Target = (props) => <IconBase name="Target" {...props} />;
        const X = (props) => <IconBase name="X" {...props} />;
        const ShieldCheck = (props) => <IconBase name="ShieldCheck" {...props} />;
        const List = (props) => <IconBase name="List" {...props} />;
        const Key = (props) => <IconBase name="Key" {...props} />;
        const Skull = (props) => <IconBase name="Skull" {...props} />;
        const ArrowUpDown = (props) => <IconBase name="ArrowUpDown" {...props} />;
        const ArrowLeftRight = (props) => <IconBase name="ArrowLeftRight" {...props} />;
        const Flame = (props) => <IconBase name="Flame" {...props} />;
        const Hourglass = (props) => <IconBase name="Hourglass" {...props} />;
        const Moon = (props) => <IconBase name="Moon" {...props} />;
        const RefreshCw = (props) => <IconBase name="RefreshCw" {...props} />;

        const WARD_PATH = [[0, 1], [0, 2], [1, 2], [2, 2], [2, 1], [2, 0], [1, 0], [0, 0]];
        const FIELD_TYPES = { BLANK: 'blank', EYE: 'eye', LOCK: 'lock' };
        const FLASH_DURATION = 500; 

        const INITIAL_USER_DECK = [
        { id: 'b1', name: 'Move U/D', type: 'move_ud', needChoice: true },
        { id: 'b2', name: 'Move U/D', type: 'move_ud', needChoice: true },
        { id: 'b3', name: 'Move L/R', type: 'move_lr', needChoice: true },
        { id: 'b4', name: 'Move L/R', type: 'move_lr', needChoice: true },
        { id: 'b5', name: 'Attack', type: 'attack', needChoice: false },
        { id: 'b6', name: 'Attack', type: 'attack', needChoice: false },
        { id: 'b7', name: 'Choice', type: 'choice_2', needChoice: true }, 
        ];

        const INITIAL_AI_DECK = [
        { id: 'p1', name: 'Move U/D', type: 'move_ud' },
        { id: 'p2', name: 'Move U/D', type: 'move_ud' },
        { id: 'p3', name: 'Move L/R', type: 'move_lr' },
        { id: 'p4', name: 'Move L/R', type: 'move_lr' },
        { id: 'p5', name: 'Shield', type: 'shield' },
        { id: 'p6', name: 'Repeat', type: 'repeat' },
        { id: 'p7', name: 'Repeat', type: 'repeat' },
        { id: 'p8', name: 'Unlock/Heal', type: 'unlock_heal' },
        { id: 'p9', name: 'Unlock/UD', type: 'unlock_move_ud' },
        { id: 'p10', name: 'Unlock/LR', type: 'unlock_move_lr' },
        ];

        const shuffle = (array) => {
        const newArr = [...array];
        for (let i = newArr.length - 1; i > 0; i--) {
            const j = Math.floor(Math.random() * (i + 1));
            [newArr[i], newArr[j]] = [newArr[j], newArr[i]];
        }
        return newArr;
        };

        const getNumberEmoji = (num) => {
        const map = ['0ï¸âƒ£', '1ï¸âƒ£', '2ï¸âƒ£', '3ï¸âƒ£', '4ï¸âƒ£', '5ï¸âƒ£', '6ï¸âƒ£', '7ï¸âƒ£', '8ï¸âƒ£', '9ï¸âƒ£'];
        return map[num] || '#ï¸âƒ£';
        };

        const getPlayerIcon = (id) => {
        switch(id) {
            case 'user': return 'ðŸŸ£'; 
            case 'red': return 'ðŸ”´';
            case 'yellow': return 'ðŸŸ¡';
            case 'green': return 'ðŸŸ¢';
            default: return 'âšª';
        }
        };

        const getDirectionText = (start, end) => {
        if (end[0] < start[0]) return "UP";
        if (end[0] > start[0]) return "DOWN";
        if (end[1] < start[1]) return "LEFT";
        if (end[1] > start[1]) return "RIGHT";
        return "STAY";
        };

        const AI_BRAIN = {
        getThreatScore: (aiPos, userPos, hasShield, isEclipse) => {
            const dist = Math.abs(aiPos[0] - userPos[0]) + Math.abs(aiPos[1] - userPos[1]);
            const isUserCorner = (userPos[0]===0||userPos[0]===2) && (userPos[1]===0||userPos[1]===2);
            let score = 0;
            if (dist === 0) {
            score = -1900; 
            }
            else if (dist === 1) {
            score = -500; 
            }
            else if (dist === 2) {
            const risk = isUserCorner ? -10 : -30;
            score = risk;
            }
            else {
            score = 20; 
            }
            return score;
        },

        getHandPermutations: (hand) => {
            const results = [];
            if (hand.length < 3) return [hand]; 

            const permute = (arr, m = []) => {
            if (m.length === 3) {
                results.push(m);
                return;
            }
            for (let i = 0; i < arr.length; i++) {
                const curr = arr.slice();
                const next = curr.splice(i, 1);
                permute(curr.slice(), m.concat(next));
            }
            };
            permute(hand);
            return results;
        },

        getBestMoveTarget: (currentPos, cardType, board, userPos, allyPositions) => {
            const [r, c] = currentPos;
            const candidates = [];
            
            if (cardType.includes('ud')) {
            if (r > 0) candidates.push([r - 1, c]);
            if (r < 2) candidates.push([r + 1, c]);
            } else if (cardType.includes('lr')) {
            if (c > 0) candidates.push([r, c - 1]);
            if (c < 2) candidates.push([r, c + 1]);
            } else {
            const neighbors = [[-1,0], [1,0], [0,-1], [0,1]];
            neighbors.forEach(([dr, dc]) => {
                const nr = r+dr, nc = c+dc;
                if (nr>=0 && nr<3 && nc>=0 && nc<3) candidates.push([nr, nc]);
            });
            }

            if (candidates.length === 0) return currentPos;

            let bestTarget = candidates[0];
            let maxScore = -Infinity;

            candidates.forEach(pos => {
            const [tr, tc] = pos;
            let score = 0;

            const distToUser = Math.abs(tr - userPos[0]) + Math.abs(tc - userPos[1]);
            if (distToUser === 0) score -= 1000;
            else if (distToUser === 1) score -= 200;
            else if (distToUser === 2) score -= 20;
            else score += 50;

            let crowdPenalty = 0;
            allyPositions.forEach(ap => {
                const dist = Math.abs(tr - ap[0]) + Math.abs(tc - ap[1]);
                if (dist === 0) crowdPenalty -= 100; 
                if (dist === 1) crowdPenalty -= 10; 
            });
            score += crowdPenalty;

            const cell = board[tr][tc];
            if (cell.type === FIELD_TYPES.LOCK && cell.dice > 0) {
                score += 80; 
                if (cell.dice === 1) score += 20; 
            }

            if (score > maxScore) {
                maxScore = score;
                bestTarget = pos;
            }
            });

            return bestTarget;
        },

        simulateSequence: (aiEntity, sequence, board, allEntities, userPos, wardPos, unlockedCount, currentTurn) => {
            let pState = { ...aiEntity, pos: [...aiEntity.pos] };
            let score = 0;
            let simUnlocked = unlockedCount; 
            let simLockHealth = {}; 
            let lastRealType = 'void'; 
            let events = []; 
            
            let simUserPos = [...userPos];

            for (let i = 0; i < sequence.length; i++) {
            const card = sequence[i];
            let type = card.type;
            
            if (type === 'repeat') {
                type = lastRealType;
            } else {
                lastRealType = type;
            }

            const [r, c] = pState.pos;
            const cell = board[r][c];
            const cellKey = `${r}-${c}`;

            let currentDice = -1;
            if (cell.type === FIELD_TYPES.LOCK) {
                if (simLockHealth[cellKey] !== undefined) {
                    currentDice = simLockHealth[cellKey];
                } else {
                    currentDice = cell.dice;
                }
            }

            const isLock = cell.type === FIELD_TYPES.LOCK && currentDice > 0;
            const isWard = r === wardPos[0] && c === wardPos[1];
            const isEye = cell.type === FIELD_TYPES.EYE;
            const isEclipse = isWard && isEye; 

            const isDesperate = currentTurn >= 4 || simUnlocked >= 2;

            if (type === 'unlock_heal') {
                if (isLock) type = 'unlock';
                else if (pState.hp < 2 && !isEclipse) type = 'heal';
                else type = 'void'; 
            } else if (type === 'unlock_move_ud') {
                if (isLock) {
                    const distToUser = Math.abs(r - simUserPos[0]) + Math.abs(c - simUserPos[1]);
                    let canFlee = false;
                    
                    if (distToUser <= 1) {
                         const candidates = [];
                         if (r > 0) candidates.push([r - 1, c]);
                         if (r < 2) candidates.push([r + 1, c]);
                         
                         if (candidates.some(([cr, cc]) => cr !== simUserPos[0] || cc !== simUserPos[1])) {
                             canFlee = true;
                         }
                    }

                    if (canFlee && !isDesperate) type = 'move_ud';
                    else type = 'unlock';
                } else {
                    const candidates = [];
                    if (r > 0) candidates.push([r - 1, c]);
                    if (r < 2) candidates.push([r + 1, c]);
                    
                    const onlyPathIsUser = candidates.length > 0 && candidates.every(([cr, cc]) => cr === simUserPos[0] && cc === simUserPos[1]);
                    
                    if (onlyPathIsUser) type = 'unlock'; 
                    else type = 'move_ud';
                }
            } else if (type === 'unlock_move_lr') {
                if (isLock) {
                    const distToUser = Math.abs(r - simUserPos[0]) + Math.abs(c - simUserPos[1]);
                    let canFlee = false;
                    
                    if (distToUser <= 1) {
                         const candidates = [];
                         if (c > 0) candidates.push([r, c - 1]);
                         if (c < 2) candidates.push([r, c + 1]);
                         
                         if (candidates.some(([cr, cc]) => cr !== simUserPos[0] || cc !== simUserPos[1])) canFlee = true;
                    }

                    if (canFlee && !isDesperate) type = 'move_lr';
                    else type = 'unlock';
                } else {
                    const candidates = [];
                    if (c > 0) candidates.push([r, c - 1]);
                    if (c < 2) candidates.push([r, c + 1]);
                    
                    const onlyPathIsUser = candidates.length > 0 && candidates.every(([cr, cc]) => cr === simUserPos[0] && cc === simUserPos[1]);
                    
                    if (onlyPathIsUser) type = 'unlock'; 
                    else type = 'move_lr';
                }
            }

            if (type.includes('unlock')) {
                if (isLock) {
                const baseScore = currentTurn >= 4 ? 1650 : 150;
                score += baseScore; 
                
                currentDice--;
                simLockHealth[cellKey] = currentDice;
                
                events.push({ type: 'damage', pos: [r, c] });

                if (currentDice >= 0) {
                    score += (7 - currentDice) * 100;
                }

                if (currentDice === 0) {
                    simUnlocked++;
                    events.push({ type: 'unlock_complete' });
                    if (simUnlocked >= 3) {
                        score += 5000;
                    }
                }

                } else {
                score -= 10; 
                }
            } else if (type.includes('heal')) {
                if (isEclipse) {
                score -= 50; 
                } else if (pState.hp < 2) {
                score += 60; 
                pState.hp = 2; 
                } else {
                score -= 5; 
                }
            } else if (type === 'shield') {
                if (isEclipse) {
                score -= 50;
                } else {
                pState.isShielded = true;
                const dist = Math.abs(pState.pos[0] - simUserPos[0]) + Math.abs(pState.pos[1] - simUserPos[1]);
                if (dist === 0) score += 100; 
                else score += 1; 
                }
            } else if (type.includes('move')) {
                const allies = Object.values(allEntities).filter(pl => pl.id !== 'user' && pl.id !== aiEntity.id).map(pl => pl.pos);
                const newPos = AI_BRAIN.getBestMoveTarget(pState.pos, type, board, simUserPos, allies); 
                
                if (newPos[0] === pState.pos[0] && newPos[1] === pState.pos[1]) {
                score -= 20; 
                } else {
                pState.pos = newPos;
                score += 10; 
                }
            }

            const threat = AI_BRAIN.getThreatScore(pState.pos, userPos, pState.isShielded, isEclipse);
            score += threat;
            
            const endCell = board[pState.pos[0]][pState.pos[1]];
            if (endCell.type === FIELD_TYPES.LOCK && endCell.dice > 0) {
                score += 40;
                const dist = Math.abs(pState.pos[0] - userPos[0]) + Math.abs(pState.pos[1] - userPos[1]);
                if (dist >= 3) score += 100; 
            }

            pState.isShielded = false;
            }

            return { score, finalPos: pState.pos, sequence, events };
        }
        };

        const ActionIcons = ({ type, size = 12, dark = false, isFlying = false }) => {
        const icons = [];
        const isCardMode = dark && !isFlying;
        
        const tacticalColor = isCardMode ? "text-[#000000]" : (isFlying ? "text-[#FFFFFF]" : `text-[${THEME_COLORS.STONE_300}]`); 
        const attackColor = isCardMode ? "text-[#000000]" : `text-[${THEME_COLORS.RED}]`; 
        const unlockColor = isCardMode ? "text-[#000000]" : `text-[${THEME_COLORS.YELLOW}]`; 
        const healColor = isCardMode ? "text-[#000000]" : `text-[${THEME_COLORS.GREEN}]`; 
        const shieldColor = isCardMode ? "text-[#000000]" : `text-[${THEME_COLORS.BLUE}]`; 
        const specialColor = isCardMode ? "text-[#000000]" : (isFlying ? "text-[#FFFFFF]" : `text-[${THEME_COLORS.PURPLE}]`);
        const voidColor = isFlying ? "text-[#FFFFFF] drop-shadow-md" : `text-[${THEME_COLORS.SLATE_400}]`; 

        if (isFlying) {
            if (type === 'attack') return <Sword size={size} className={attackColor} />;
            if (type === 'assault') return <Swords size={size} className={attackColor} />;
            if (type === 'unlock') return <Key size={size} className={unlockColor} />;
            if (type === 'heal') return <Heart size={size} className={healColor} />;
            if (type === 'shield') return <Shield size={size} className={shieldColor} />;
            if (type === 'move_ud') return <ArrowUpDown size={size} className={tacticalColor} />;
            if (type === 'move_lr') return <ArrowLeftRight size={size} className={tacticalColor} />;
            if (type === 'move_4') return <Move size={size} className={tacticalColor} />;
            if (type === 'move_8') return <Move size={size} className={tacticalColor} />;
            if (type === 'repeat') return <RotateCcw size={size} className={specialColor} />;
            if (type.includes('choice')) return <HelpCircle size={size} className={specialColor} />;
            if (type === 'void') return <Moon size={size} className={voidColor} />;
            
            if (type.includes('move')) return type.includes('ud') ? <ArrowUpDown size={size} className={tacticalColor} /> : <ArrowLeftRight size={size} className={tacticalColor} />;
            if (type.includes('unlock')) return <Key size={size} className={unlockColor} />;
            return null;
        }

        if (type.includes('move')) {
            if (type.includes('ud')) icons.push(<ArrowUpDown key="ud" size={size} className={tacticalColor} />);
            else if (type.includes('lr')) icons.push(<ArrowLeftRight key="lr" size={size} className={tacticalColor} />);
            else icons.push(<Move key="m8" size={size} className={tacticalColor} />); 
        }
        
        if (type === 'attack') {
            icons.push(<Sword key="atk" size={size} className={attackColor} />);
        } else if (type.includes('attack') || type === 'assault') {
            icons.push(<Swords key="atk" size={size} className={attackColor} />);
        }

        if (type.includes('unlock')) icons.push(<Key key="unl" size={size} className={unlockColor} />);
        if (type.includes('heal')) icons.push(<Heart key="heal" size={size} className={healColor} />);
        if (type.includes('shield')) icons.push(<Shield key="shi" size={size} className={shieldColor} />);
        
        if (type.includes('repeat')) icons.push(<RotateCcw key="rep" size={size} className={tacticalColor} />);
        if (type.includes('choice')) icons.push(<HelpCircle key="cho" size={size} className={tacticalColor} />);
        
        if (type === 'void') icons.push(<Moon key="void" size={size} className={voidColor} />);
        
        return <div className="flex items-center gap-1 justify-center">{icons}</div>;
        };

        const TokenLayer = ({ entities }) => {
        return (
            <div className="absolute inset-0 pointer-events-none z-40 overflow-visible">
            {Object.values(entities).map(p => {
                const [row, col] = p.pos;
                if (row < 0 || col < 0 || p.isDead || p.isRecovering) return null;
                
                const samePosEntities = Object.values(entities).filter(other => 
                other.pos[0] === row && other.pos[1] === col && !other.isDead && !other.isRecovering
                );
                const pIdx = samePosEntities.findIndex(c => c.id === p.id);
                
                let offsetX = 0, offsetY = 0;
                if (samePosEntities.length > 1 && pIdx !== -1) {
                offsetX = (pIdx % 2 === 0 ? -10 : 10);
                offsetY = (pIdx < 2 ? -10 : 10);
                }

                const xPercent = col * 100;
                const yPercent = row * 100;

                const isDamagedAi = p.type === 'ai' && p.hp === 1;
                const backgroundStyle = isDamagedAi
                ? { background: `linear-gradient(to bottom, transparent 50%, ${COLORS[p.color]} 50%)`, backgroundRepeat: 'no-repeat' }
                : { backgroundColor: COLORS[p.color] };

                return (
                <div key={p.id} id={`token-${p.id}`}
                    className="absolute w-[33.33%] h-[33.33%] flex items-center justify-center transition-transform duration-1000 ease-in-out will-change-transform"
                    style={{
                    transform: `translate3d(${xPercent}%, ${yPercent}%, 0)`,
                    zIndex: p.id === 'user' ? 50 : 45
                    }}
                >
                    <div 
                    className={`w-9 h-9 md:w-11 md:h-11 rounded-full border-2 border-[#00000066] flex items-center justify-center shadow-xl transition-all duration-300 ring-1 ring-[#ffffff33]`}
                    style={{ 
                        ...backgroundStyle,
                        transform: `translate(${offsetX}px, ${offsetY}px) scale(0.85)`
                    }}
                    >
                    <div className="text-[#FFFFFF] drop-shadow-[0_2px_2px_rgba(0,0,0,0.5)] flex items-center justify-center w-full h-full">
                        {p.isShielded ? (
                            <Shield size={18} />
                        ) : p.id === 'user' ? (
                            <Eye size={18} />
                        ) : (
                            <User size={18} />
                        )}
                    </div>
                    </div>
                </div>
                );
            })}
            </div>
        );
        };

        const MiniStatus = ({ player, onClick }) => {
        const getHardCodedColor = (color) => {
            if (color === 'red') return THEME_COLORS.RED;
            if (color === 'yellow') return THEME_COLORS.YELLOW;
            if (color === 'green') return THEME_COLORS.GREEN;
            if (color === 'purple') return THEME_COLORS.PURPLE;
            return '#44403c';
        };

        const statusColor = (player.isDead || player.isRecovering) ? '#44403c' : getHardCodedColor(player.color);

        return (
            <div onClick={() => onClick(player)} 
            className={`flex-1 p-1.5 rounded-lg border-2 flex items-center gap-2 transition-all cursor-pointer 
            ${player.isDead || player.isRecovering ? `opacity-40 grayscale bg-[${THEME_COLORS.BG_DARK}]` : `bg-[${THEME_COLORS.BG_PANEL}] shadow-md hover:border-[#FFFFFF]`}`}
            style={{ borderColor: statusColor }}
            >
            <div className="flex flex-col gap-0.5 justify-center">
                {player.id === 'user' ? (
                <Eye size={10} style={{ color: THEME_COLORS.PURPLE }} />
                ) : (
                [...Array(2)].map((_, i) => (
                    <Heart key={i} size={8} 
                    style={{ 
                        color: i < player.hp ? getHardCodedColor(player.color) : '#292524', 
                        fill: i < player.hp ? getHardCodedColor(player.color) : 'transparent' 
                    }} 
                    />
                ))
                )}
            </div>
            <div className="flex flex-col gap-0.5 text-[7px] font-bold opacity-90 flex-1 font-serif text-[#d7ccc8]">
                <div className="flex items-center gap-1"><Layers size={8} className={`text-[${THEME_COLORS.BROWN_MID}]`}/>{player.deck.length}</div>
                <div className="flex items-center gap-1"><Archive size={8} className="text-[#5d4037]"/>{player.discard.length}</div>
            </div>
            </div>
        );
        };

        const CinematicAction = ({ effect }) => {
        if (!effect) return null;
        const { iconType, color, start, center, end } = effect; 

        const colorMap = {
            purple: `text-[${THEME_COLORS.PURPLE}] drop-shadow-[0_0_15px_${THEME_COLORS.PURPLE}] border-[${THEME_COLORS.PURPLE}80] bg-[${THEME_COLORS.PURPLE}66]`,
            red: `text-[${THEME_COLORS.RED}] drop-shadow-[0_0_15px_${THEME_COLORS.RED}] border-[${THEME_COLORS.RED}80] bg-[${THEME_COLORS.RED}66]`,
            yellow: `text-[${THEME_COLORS.YELLOW}] drop-shadow-[0_0_15px_${THEME_COLORS.YELLOW}] border-[${THEME_COLORS.YELLOW}80] bg-[${THEME_COLORS.YELLOW}66]`,
            green: `text-[${THEME_COLORS.GREEN}] drop-shadow-[0_0_15px_${THEME_COLORS.GREEN}] border-[${THEME_COLORS.GREEN}80] bg-[${THEME_COLORS.GREEN}66]`
        };
        const styleClass = colorMap[color] || colorMap.purple;

        return (
            <div className="fixed inset-0 pointer-events-none z-[9999] overflow-hidden">
            <div 
                className="animate-cinematic-fly absolute flex items-center justify-center w-20 h-20" 
                style={{
                '--start-x': `${start.x}px`, '--start-y': `${start.y}px`,
                '--center-x': `${center.x}px`, '--center-y': `${center.y}px`,
                '--end-x': `${end.x}px`, '--end-y': `${end.y}px`,
                left: 0, top: 0, transform: 'translate(-50%, -50%)'
                }}
            >
                <div className={`w-full h-full rounded-full border-[6px] backdrop-blur-md flex items-center justify-center shadow-2xl ${styleClass}`}>
                    <ActionIcons type={iconType} size={40} isFlying={true} />
                </div>
            </div>
            </div>
        );
        };

        function App() {
        const [board, setBoard] = useState([]);
        const [entities, setEntities] = useState({
            user: { id: 'user', name: 'USER', pos: [1, 1], hp: 99, deck: [], hand: [], discard: [], color: 'purple', type: 'user', isShielded: false, isDead: false, isRecovering: false },
            red: { id: 'red', name: 'RED', pos: [1, 1], hp: 2, deck: [], hand: [], discard: [], color: 'red', type: 'ai', isShielded: false, isDead: false, isRecovering: false },
            yellow: { id: 'yellow', name: 'YEL', pos: [1, 1], hp: 2, deck: [], hand: [], discard: [], color: 'yellow', type: 'ai', isShielded: false, isDead: false, isRecovering: false },
            green: { id: 'green', name: 'GRN', pos: [1, 1], hp: 2, deck: [], hand: [], discard: [], color: 'green', type: 'ai', isShielded: false, isDead: false, isRecovering: false },
        });
        
        const [wardPos, setWardPos] = useState([0, 1]);
        const [unlockedCount, setUnlockedCount] = useState(0);
        const [remainingRounds, setRemainingRounds] = useState(8); 
        const [gameTurn, setGameTurn] = useState(1); 
        const [gamePhase, setGamePhase] = useState('setup'); 
        const [actionArray, setActionArray] = useState(Array(12).fill(null)); 
        const [resolvingIndex, setResolvingIndex] = useState(-1);
        const [logs, setLogs] = useState([]); 
        const [isLogExpanded, setIsLogExpanded] = useState(false);
        const [winner, setWinner] = useState(null);
        const [flashCell, setFlashCell] = useState(null); 
        const [selectableCells, setSelectableCells] = useState([]); 
        const [viewingDiscard, setViewingDiscard] = useState(null);
        const [activeSelection, setActiveSelection] = useState(null); 
        const [cinematicEffect, setCinematicEffect] = useState(null); 
        const [confirmNewGame, setConfirmNewGame] = useState(false);
        const [resumeTrigger, setResumeTrigger] = useState(false);
        const [checkpoint, setCheckpoint] = useState(null);
        
        const gameVersionRef = useRef(0);
        
        const interactionResolverRef = useRef(null);
        
        // [New] Ref to hold the resolver for the pending promise
        // This is key to fixing the dangling promise issue
        const pendingPromiseResolverRef = useRef(null);
        
        const addLog = (msg) => setLogs(prev => [String(msg), ...prev].slice(0, 50));

        const startFreshGame = () => {
            gameVersionRef.current += 1;

            // [Fix] Force resolve any hanging promise with dummy data
            if (pendingPromiseResolverRef.current) {
                pendingPromiseResolverRef.current([-1, -1]); // Resolve with dummy
                pendingPromiseResolverRef.current = null;
            }

            setFlashCell(null);
            setSelectableCells([]);
            setCinematicEffect(null);
            setActiveSelection(null);
            setViewingDiscard(null);
            setResumeTrigger(false);

            const fields = shuffle([...Array(3).fill(FIELD_TYPES.BLANK), FIELD_TYPES.EYE, ...Array(5).fill(FIELD_TYPES.LOCK)]);
            const rawDicePool = [4, 5, 5, 6, 6, 7];
            const selectedDice = shuffle(rawDicePool).slice(0, 5);
            let diceIndex = 0;

            const newBoard = [];
            for(let i=0; i<3; i++) {
                newBoard[i] = [];
                for(let j=0; j<3; j++) {
                    const type = fields[i * 3 + j];
                    const dice = type === FIELD_TYPES.LOCK ? selectedDice[diceIndex++] : null;
                    newBoard[i][j] = { type, dice, id: `cell-${i}-${j}`, hourglass: false };
                }
            }
            
            const lockCoords = [];
            newBoard.forEach((row, r) => row.forEach((cell, c) => {
                if (cell.type === FIELD_TYPES.LOCK) lockCoords.push([r, c]);
            }));

            if (lockCoords.length > 0) {
                const randIndex = Math.floor(Math.random() * lockCoords.length);
                const [hr, hc] = lockCoords[randIndex];
                newBoard[hr][hc].hourglass = true;
            }

            const nextEntities = {
                user: { id: 'user', name: 'USER', pos: [1, 1], hp: 99, deck: [], hand: [], discard: [], color: 'purple', type: 'user', isShielded: false, isDead: false, isRecovering: false },
                red: { id: 'red', name: 'RED', pos: [1, 1], hp: 2, deck: [], hand: [], discard: [], color: 'red', type: 'ai', isShielded: false, isDead: false, isRecovering: false },
                yellow: { id: 'yellow', name: 'YEL', pos: [1, 1], hp: 2, deck: [], hand: [], discard: [], color: 'yellow', type: 'ai', isShielded: false, isDead: false, isRecovering: false },
                green: { id: 'green', name: 'GRN', pos: [1, 1], hp: 2, deck: [], hand: [], discard: [], color: 'green', type: 'ai', isShielded: false, isDead: false, isRecovering: false },
            };

            ['red', 'yellow', 'green', 'user'].forEach(id => {
                const deckSource = (id === 'user') ? INITIAL_USER_DECK : INITIAL_AI_DECK;
                nextEntities[id].deck = shuffle([...deckSource]);
                
                if (id !== 'user') nextEntities[id].pos = findBestSpawnPos(newBoard, nextEntities, [0, 1], id, true);
                else nextEntities[id].pos = [1, 1];
            });

            setBoard(newBoard);
            setEntities(nextEntities);
            setWardPos([0, 1]);
            setUnlockedCount(0);
            setRemainingRounds(8);
            setGameTurn(1);
            setGamePhase('setup');
            setActionArray(Array(12).fill(null));
            setWinner(null); 
            setLogs([]); 
            setCheckpoint(null);
            setConfirmNewGame(false); 

            startNewRound(nextEntities, [0, 1], newBoard, 0, 1);
        };

        useEffect(() => {
            const savedData = localStorage.getItem(SAVE_KEY);
            if (savedData) {
                try {
                    const state = JSON.parse(savedData);
                    
                    if (state.gamePhase === 'resolving' && state.checkpoint) {
                        const cp = state.checkpoint;
                        setBoard(cp.board);
                        setEntities(cp.entities);
                        setWardPos(cp.wardPos);
                        setUnlockedCount(cp.unlockedCount);
                        setRemainingRounds(cp.remainingRounds);
                        setGameTurn(cp.gameTurn);
                        setGamePhase('resolving');
                        setActionArray(cp.actionArray);
                        setLogs(cp.logs);
                        setCheckpoint(cp);
                        addLog("â†º æˆ°é¬¥é‡æ’­ (Replay)");
                        setResumeTrigger(true);
                    } else {
                        setBoard(state.board);
                        setEntities(state.entities);
                        setWardPos(state.wardPos);
                        setUnlockedCount(state.unlockedCount);
                        setRemainingRounds(state.remainingRounds);
                        setGameTurn(state.gameTurn);
                        setGamePhase(state.gamePhase);
                        setActionArray(state.actionArray);
                        setLogs(state.logs);
                        setWinner(state.winner);
                        setCheckpoint(state.checkpoint);
                        addLog("ðŸ’¾ éŠæˆ²è¼‰å…¥ (Game Loaded)");
                    }
                    return; 
                } catch (e) {
                    console.error("Save file corrupted", e);
                }
            }
            startFreshGame();
        }, []);

        useEffect(() => {
            if (gamePhase === 'setup') return;
            const stateToSave = {
                board, entities, wardPos, unlockedCount, remainingRounds, 
                gameTurn, gamePhase, actionArray, logs, winner,
                checkpoint
            };
            localStorage.setItem(SAVE_KEY, JSON.stringify(stateToSave));
        }, [board, entities, wardPos, unlockedCount, remainingRounds, gameTurn, gamePhase, actionArray, logs, winner, checkpoint]);

        useEffect(() => {
            if (resumeTrigger && entities.user.id === 'user') {
                setResumeTrigger(false);
                resolveActions(actionArray, 0);
            }
        }, [resumeTrigger]); 

        const handleSoftReset = () => {
            setConfirmNewGame(false);
            localStorage.removeItem(SAVE_KEY);
            startFreshGame();
        };

        const findBestSpawnPos = (currentBoard, currentEntities, currentWard, currentPlayerId, isGameStart = false) => {
            const candidates = [];
            currentBoard.forEach((row, r) => row.forEach((cell, c) => {
            const isUserPos = r === currentEntities.user.pos[0] && c === currentEntities.user.pos[1];
            const isWard = r === currentWard[0] && c === currentWard[1];
            const isEye = cell.type === FIELD_TYPES.EYE;
            const occupied = Object.values(currentEntities).some(p => p.pos[0] === r && p.pos[1] === c && !p.isDead && !p.isRecovering && p.id !== currentPlayerId);
            
            if ((!cell.dice || cell.dice === 0) && !isUserPos && !occupied) {
                let score = 0;
                if (isWard) score -= 100;
                
                if (isGameStart) {
                    if (isWard) score -= 2000;
                    if (isEye) score -= 2000;
                }

                score += AI_BRAIN.getThreatScore([r,c], currentEntities.user.pos, false, false);

                Object.values(currentEntities).forEach(p => {
                if (p.type === 'ai' && !p.isDead && p.id !== currentPlayerId) {
                    const d = Math.abs(r-p.pos[0]) + Math.abs(c-p.pos[1]);
                    if (d < 2) score -= 50; 
                }
                });
                candidates.push({ pos: [r,c], score });
            }
            }));
            
            candidates.sort((a,b) => b.score - a.score);
            return candidates.length > 0 ? candidates[0].pos : [0,0];
        };

        const planTeamStrategy = (currentEntities, currentBoard, currentWard, currentUnlockedCount, currentTurn) => {
            const userPos = currentEntities.user.pos;
            const teamOrders = [
            ['red', 'yellow', 'green'], ['red', 'green', 'yellow'],
            ['yellow', 'red', 'green'], ['yellow', 'green', 'red'],
            ['green', 'red', 'yellow'], ['green', 'yellow', 'red']
            ];

            let bestTeamScore = -Infinity;
            let bestPlan = {};

            const simBoard = currentBoard; 
            
            teamOrders.forEach(order => {
            let orderScore = 0;
            let orderPlan = {};
            
            let simEntities = JSON.parse(JSON.stringify(currentEntities));
            let simBoard = JSON.parse(JSON.stringify(currentBoard)); 
            let simUnlocked = currentUnlockedCount;

            order.forEach(pid => {
                const p = simEntities[pid];
                if (p.isDead || p.isRecovering) return; 

                const handPerms = AI_BRAIN.getHandPermutations(p.hand);
                
                let bestPermScore = -Infinity;
                let bestPermResult = null;

                handPerms.forEach(seq => {
                    const result = AI_BRAIN.simulateSequence(p, seq, simBoard, simEntities, userPos, currentWard, simUnlocked, currentTurn);
                    if (result.score > bestPermScore) {
                    bestPermScore = result.score;
                    bestPermResult = result;
                    }
                });

                if (bestPermResult) {
                orderScore += bestPermResult.score;
                orderPlan[pid] = bestPermResult.sequence;
                
                p.pos = bestPermResult.finalPos;

                if (bestPermResult.events) {
                    bestPermResult.events.forEach(event => {
                        if (event.type === 'damage') {
                            const [er, ec] = event.pos;
                            if (simBoard[er][ec].dice > 0) {
                                simBoard[er][ec].dice--;
                            }
                        } else if (event.type === 'unlock_complete') {
                            simUnlocked++;
                        }
                    });
                }
                }
            });

            if (orderScore > bestTeamScore) {
                bestTeamScore = orderScore;
                bestPlan = orderPlan;
            }
            });

            return bestPlan;
        };

        const startNewRound = async (currentEntities, currentWard, currentBoard, currentUnlocked, currentTurn) => {
            setCheckpoint(null);
            
            const p = JSON.parse(JSON.stringify(currentEntities));
            
            Object.values(p).forEach(player => {
            if (player.isRecovering) {
                player.isRecovering = false;
                player.isDead = false; 
                player.hp = player.type === 'user' ? 99 : 1;
                player.pos = findBestSpawnPos(currentBoard, p, currentWard, player.id);
                addLog(`âœ¨ ${getPlayerIcon(player.id)} Respawned`);
            } else if (player.isDead) {
                player.isRecovering = true;
                player.hand = [];
                addLog(`ðŸ”§ ${getPlayerIcon(player.id)} Recovering...`);
            }
            if (player.hand.length > 0) { player.discard = [...player.discard, ...player.hand]; player.hand = []; }
            player.isShielded = false;
            });

            const userPool = shuffle([...p.user.deck, ...p.user.discard]);
            p.user.discard = userPool.slice(0, 2); 
            p.user.hand = p.user.isRecovering ? [] : userPool.slice(2, 7); 
            p.user.deck = userPool.slice(7); 
            
            ['red', 'yellow', 'green'].forEach(id => {
            if (!p[id].isRecovering) {
                if (p[id].deck.length < 5) { p[id].deck = shuffle([...p[id].deck, ...p[id].discard]); p[id].discard = []; }
                p[id].hand = p[id].deck.slice(0, 5); p[id].deck = p[id].deck.slice(5);
                p[id].faceUpMove = Math.floor(Math.random() * 3); 
            }
            });

            addLog(`ðŸ§  AI Thinking...`);
            const bestPlan = planTeamStrategy(p, currentBoard, currentWard, currentUnlocked, currentTurn);
            
            const newArray = Array(12).fill(null);
            for (let moveIdx = 0; moveIdx < 3; moveIdx++) {
            ['red', 'yellow', 'green'].forEach((pid, i) => {
                const pObj = p[pid];
                let cardToPlay = null;

                if (bestPlan[pid] && bestPlan[pid][moveIdx]) {
                    cardToPlay = bestPlan[pid][moveIdx];
                    const idx = pObj.hand.findIndex(c => c.id === cardToPlay.id);
                    if (idx !== -1) pObj.hand.splice(idx, 1);
                } else if (pObj.hand.length > 0) {
                    cardToPlay = pObj.hand.shift();
                }

                if (cardToPlay) {
                    const isFaceUp = (currentBoard[pObj.pos[0]][pObj.pos[1]].type === FIELD_TYPES.EYE) || 
                                    (pObj.pos[0] === currentWard[0] && pObj.pos[1] === currentWard[1]) ||
                                    (pObj.faceUpMove === moveIdx);
                    newArray[moveIdx * 4 + i] = { playerId: pid, card: cardToPlay, visible: isFaceUp };
                }
            });
            }

            setEntities(p); setGamePhase('planning'); setActionArray(newArray); setResolvingIndex(-1);
            addLog(`>>> Planning Phase`);
        };

        const triggerCinematic = (slotIdx, playerId, iconType, targetPos) => {
            return new Promise(resolve => {
            const slotElem = document.getElementById(`slot-${slotIdx}`);
            const boardElem = document.getElementById('board-container');
            const cellElem = document.getElementById(`cell-${targetPos[0]}-${targetPos[1]}`);
            const tokenElem = document.getElementById(`token-${playerId}`);

            let startPos = { x: 0, y: 0 };
            let centerPos = { x: window.innerWidth / 2, y: window.innerHeight / 2 };
            let endPos = { x: 0, y: 0 };

            if (slotElem) {
                const r = slotElem.getBoundingClientRect();
                startPos = { x: r.left + r.width/2, y: r.top + r.height/2 };
            }
            if (boardElem) {
                const br = boardElem.getBoundingClientRect();
                centerPos = { x: br.left + br.width/2, y: br.top + br.height/2 };
            }
            if (cellElem) {
                const er = cellElem.getBoundingClientRect();
                endPos = { x: er.left + er.width/2, y: er.top + er.height/2 };
            } else if (tokenElem) {
                const tr = tokenElem.getBoundingClientRect();
                endPos = { x: tr.left + tr.width/2, y: tr.top + tr.height/2 };
            }

            setCinematicEffect({ iconType, color: entities[playerId].color, start: startPos, center: centerPos, end: endPos });
            setTimeout(() => { setCinematicEffect(null); resolve(); }, 2000);
            });
        };

        const resolveActions = async (finalArray, startIndex = 0) => {
            const currentRunVersion = gameVersionRef.current;

            let curEntities = JSON.parse(JSON.stringify(entities));
            let curBoard = JSON.parse(JSON.stringify(board));
            let curUnlocked = unlockedCount;
            let curWard = [...wardPos];
            let lastCardType = { user: null, red: null, yellow: null, green: null }; 
            let queue = [...finalArray];
            
            // [Fix] Correct variable usage (remainingRounds instead of doomCounter)
            let curRounds = remainingRounds;

            const isDesperate = gameTurn >= 4 || curUnlocked >= 2;

            for (let i = startIndex; i < queue.length; i++) {
            
            if (gameVersionRef.current !== currentRunVersion) return;

            setResolvingIndex(i);
            const action = queue[i];
            const moveNum = Math.floor(i / 4) + 1;
            const order = (i % 4) + 1;
            
            const numberEmoji = getNumberEmoji(order);
            const playerIcon = action ? getPlayerIcon(action.playerId) : '';
            const logPrefix = `R${gameTurn}M${moveNum}${numberEmoji}`;

            if (!action) { await new Promise(r => setTimeout(r, 200)); continue; }
            const p = curEntities[action.playerId];
            if (p.isDead || p.hp <= 0) { await new Promise(r => setTimeout(r, 200)); continue; }

            let effectiveType = action.card.type;
            if (effectiveType === 'repeat') {
                effectiveType = lastCardType[p.id] || 'void';
            } else {
                lastCardType[p.id] = effectiveType;
            }
            
            const currentCell = curBoard[p.pos[0]][p.pos[1]];
            const isLocked = currentCell.type === 'lock' && currentCell.dice > 0;

            if (effectiveType === 'unlock_heal') {
                if (isLocked) effectiveType = 'unlock';
                else if (p.hp < 2) effectiveType = 'heal';
                else effectiveType = 'void';
            } else if (effectiveType === 'unlock_move_ud') {
                if (isLocked) {
                    const dist = Math.abs(p.pos[0] - curEntities.user.pos[0]) + Math.abs(p.pos[1] - curEntities.user.pos[1]);
                    let canFlee = false;
                    
                    if (dist <= 1) {
                         const [r, c] = p.pos;
                         const [ur, uc] = curEntities.user.pos;
                         
                         const candidates = [];
                         if (r > 0) candidates.push([r - 1, c]);
                         if (r < 2) candidates.push([r + 1, c]);
                         
                         if (candidates.some(([cr, cc]) => cr !== ur || cc !== uc)) {
                             canFlee = true;
                         }
                    }

                    if (canFlee && !isDesperate) effectiveType = 'move_ud';
                    else effectiveType = 'unlock';
                } else {
                    const [r, c] = p.pos; 
                    const candidates = [];
                    if (r > 0) candidates.push([r - 1, c]);
                    if (r < 2) candidates.push([r + 1, c]);
                    
                    const onlyPathIsUser = candidates.length > 0 && candidates.every(([cr, cc]) => cr === curEntities.user.pos[0] && cc === curEntities.user.pos[1]);
                    
                    if (onlyPathIsUser) effectiveType = 'unlock';
                    else effectiveType = 'move_ud';
                }
            } else if (effectiveType === 'unlock_move_lr') {
                if (isLocked) {
                    const dist = Math.abs(p.pos[0] - curEntities.user.pos[0]) + Math.abs(p.pos[1] - curEntities.user.pos[1]);
                    let canFlee = false;
                    
                    if (dist <= 1) {
                         const [r, c] = p.pos;
                         const [ur, uc] = curEntities.user.pos;
                         
                         const candidates = [];
                         if (c > 0) candidates.push([r, c - 1]);
                         if (c < 2) candidates.push([r, c + 1]);
                         
                         if (candidates.some(([cr, cc]) => cr !== ur || cc !== uc)) {
                             canFlee = true;
                         }
                    }

                    if (canFlee && !isDesperate) effectiveType = 'move_lr';
                    else effectiveType = 'unlock';
                } else {
                    const [r, c] = p.pos; 
                    const candidates = [];
                    if (c > 0) candidates.push([r, c - 1]);
                    if (c < 2) candidates.push([r, c + 1]);
                    
                    const onlyPathIsUser = candidates.length > 0 && candidates.every(([cr, cc]) => cr === curEntities.user.pos[0] && cc === curEntities.user.pos[1]);
                    
                    if (onlyPathIsUser) type = 'unlock'; 
                    else effectiveType = 'move_lr';
                }
            }

            let targetPos = [...p.pos];
            
            if (action.playerId === 'user' && effectiveType !== 'void') {
                if (effectiveType.includes('move')) {
                    const valid = []; const [ur, uc] = p.pos;
                    if (effectiveType === 'move_ud') { if (ur > 0) valid.push([ur-1, uc]); if (ur < 2) valid.push([ur+1, uc]); }
                    else { if (uc > 0) valid.push([ur, uc-1]); if (uc < 2) valid.push([ur, uc+1]); }
                    
                    if (valid.length === 1) {
                        targetPos = valid[0];
                    } else if (valid.length > 1) {
                        targetPos = await new Promise(r => { setSelectableCells(valid); interactionResolverRef.current = r; });
                        setSelectableCells([]);
                    }
                } else if (effectiveType === 'choice_2') {
                    const [r, c] = p.pos;
                    const valid = [[r, c]]; 
                    const neighbors = [[-1, 0], [1, 0], [0, -1], [0, 1]];
                    neighbors.forEach(([dr, dc]) => {
                        const nr = r + dr, nc = c + dc;
                        if(nr >= 0 && nr < 3 && nc >= 0 && nc < 3) valid.push([nr, nc]); 
                    });
                    
                    addLog(`${logPrefix} ${playerIcon} : Select Tile`);
                    
                    // [Fix] Store the resolve function in TWO places:
                    const selectedPos = await new Promise(r => {
                        setSelectableCells(valid);
                        interactionResolverRef.current = r;
                        pendingPromiseResolverRef.current = r; // Store for force-quitting
                    });
                    
                    // Clear the pending ref after resolution
                    pendingPromiseResolverRef.current = null;
                    setSelectableCells([]); // Clear UI immediately after resolution

                    // [Fix] Immediately check version to prevent zombie logic usage
                    // If reset happened during await, this will return and prevent crash
                    if (gameVersionRef.current !== currentRunVersion) return;
                    
                    if (selectedPos[0] === r && selectedPos[1] === c) {
                        effectiveType = 'assault';
                    } else {
                        effectiveType = 'move_4';
                        targetPos = selectedPos;
                    }
                }
            } 
            else if (effectiveType.includes('move')) {
                const allies = Object.values(curEntities).filter(pl => pl.id !== 'user' && pl.id !== p.id && !pl.isDead).map(pl => pl.pos);
                targetPos = AI_BRAIN.getBestMoveTarget(p.pos, effectiveType, curBoard, curEntities.user.pos, allies);
            }

            let visualType = effectiveType;
            if (effectiveType.includes('unlock') && (!currentCell.dice || currentCell.dice <= 0)) {
                visualType = 'void';
            }

            if (gameVersionRef.current !== currentRunVersion) return;
            await triggerCinematic(i, p.id, visualType, targetPos);

            const startPosStr = `(${p.pos[0]},${p.pos[1]})`;
            const endPosStr = `(${targetPos[0]},${targetPos[1]})`;
            let logDetail = "";

            if (effectiveType !== 'void') {
                if (effectiveType.includes('unlock')) {
                    if (curBoard[p.pos[0]][p.pos[1]].dice > 0) {
                        const oldDice = curBoard[p.pos[0]][p.pos[1]].dice;
                        curBoard[p.pos[0]][p.pos[1]].dice--;
                        const newDice = curBoard[p.pos[0]][p.pos[1]].dice;
                        setFlashCell({ pos: p.pos, type: 'unlock' });
                        logDetail = `Unlock Attempt (Dice: ${oldDice} -> ${newDice})`;
                        
                        if (curBoard[p.pos[0]][p.pos[1]].dice === 0) {
                        curUnlocked++;
                        logDetail = `ðŸ”“ Unlocked!`;
                        
                        if (curUnlocked >= 3) {
                            setWinner('Survivors');
                            setUnlockedCount(curUnlocked);
                            setBoard([...curBoard]);
                            return; 
                        }

                        if (curBoard[p.pos[0]][p.pos[1]].hourglass) {
                            addLog("â³ Time Reversed! (Round +1)");
                            curBoard.forEach(row => row.forEach(cell => { if (cell.type === FIELD_TYPES.EYE) cell.type = FIELD_TYPES.BLANK; }));
                            curBoard[p.pos[0]][p.pos[1]].type = FIELD_TYPES.BLANK;
                            curBoard[p.pos[0]][p.pos[1]].hourglass = false;
                            const currentWardIdx = WARD_PATH.findIndex(w => w[0] === curWard[0] && w[1] === curWard[1]);
                            const prevIdx = (currentWardIdx - 1 + WARD_PATH.length) % WARD_PATH.length;
                            curWard = WARD_PATH[prevIdx];
                            setWardPos(curWard);
                            curRounds++; 
                            setRemainingRounds(prev => prev + 1); 
                        } else {
                            curBoard[p.pos[0]][p.pos[1]].type = FIELD_TYPES.EYE;
                        }
                        }
                    } else {
                        logDetail = "Action Voided (Already Open)";
                        setFlashCell({ pos: p.pos, type: 'attack_gray' });
                    }
                } else if (effectiveType.includes('heal')) {
                    const isWardHere = p.pos[0] === curWard[0] && p.pos[1] === curWard[1];
                    const isEyeHere = curBoard[p.pos[0]][p.pos[1]].type === FIELD_TYPES.EYE;
                    if (isWardHere && isEyeHere) {
                    logDetail = "Heal Failed (Eclipse)"; 
                    setFlashCell({ pos: p.pos, type: 'attack_gray' });
                    } else if (p.hp < 2) {
                    p.hp++;
                    setFlashCell({ pos: p.pos, type: 'heal_success' });
                    logDetail = `â¤ï¸ Healed (HP ${p.hp})`;
                    } else {
                    logDetail = "Heal Failed (Full HP)";
                    }
                } else if (effectiveType === 'shield') { 
                    const isWardHere = p.pos[0] === curWard[0] && p.pos[1] === curWard[1];
                    const isEyeHere = curBoard[p.pos[0]][p.pos[1]].type === FIELD_TYPES.EYE;
                    if (isWardHere && isEyeHere) {
                    logDetail = "Shield Failed (Eclipse)";
                    setFlashCell({ pos: p.pos, type: 'attack_gray' });
                    } else {
                    p.isShielded = true; setFlashCell({ pos: p.pos, type: 'shield' }); 
                    logDetail = "ðŸ›¡ï¸ Shield Activated";
                    }
                } else if (effectiveType === 'attack') {
                    let hits = 0;
                    let hitDetails = [];
                    
                    Object.values(curEntities).forEach(target => {
                    if (target.id !== 'user' && target.pos[0] === p.pos[0] && target.pos[1] === p.pos[1]) {
                        if (target.isShielded) { 
                            target.isShielded = false; 
                            hitDetails.push(`Blocked by ${getPlayerIcon(target.id)}`);
                        } else {
                        const oldHp = target.hp;
                        target.hp--; hits++;
                        hitDetails.push(`Hit ${getPlayerIcon(target.id)} (HP ${oldHp}->${target.hp})`);
                        if (target.hp <= 0) {
                            target.isDead = true; target.pos = [-1, -1]; 
                            for (let k = i + 1; k < queue.length; k++) if (queue[k]?.playerId === target.id) { curEntities[target.id].discard.push(queue[k].card); queue[k] = null; }
                            setActionArray([...queue]);
                        }
                        }
                    }
                    });
                    setFlashCell({ pos: p.pos, type: hits > 0 ? 'damage' : 'attack_gray' });
                    
                    if(hitDetails.length > 0) logDetail = `${hitDetails.join(", ")}`;
                    else logDetail = "Attack Missed";

                } else if (effectiveType === 'assault') {
                    let hits = 0;
                    let assaultDetails = [];
                    const targets = Object.values(curEntities).filter(t => t.id !== 'user' && t.pos[0] === p.pos[0] && t.pos[1] === p.pos[1]);
                    
                    if (targets.length === 0) {
                        logDetail = "Attack Missed";
                        setFlashCell({ pos: p.pos, type: 'attack_gray' });
                    } else if (targets.length === 1 && !targets[0].isDead) {
                        const t = targets[0];
                        let hit1Msg = "";
                        let hit2Msg = "";
                        let damageDealt = false;

                        if (t.isShielded) {
                            t.isShielded = false;
                            hit1Msg = `1st Blocked by ${getPlayerIcon(t.id)}`;
                        } else {
                            const oldHp = t.hp;
                            t.hp--; hits++; damageDealt = true;
                            hit1Msg = `1st Hit ${getPlayerIcon(t.id)} (HP ${oldHp}->${t.hp})`;
                        }

                        if (!t.isDead && t.hp > 0) {
                            const oldHp2 = t.hp;
                            t.hp--; hits++; damageDealt = true;
                            hit2Msg = `2nd Hit ${getPlayerIcon(t.id)} (HP ${oldHp2}->${t.hp})`;
                        }

                        if (t.hp <= 0) {
                            t.isDead = true; t.pos = [-1, -1];
                            for (let k = i + 1; k < queue.length; k++) if (queue[k]?.playerId === t.id) { curEntities[t.id].discard.push(queue[k].card); queue[k] = null; }
                            setActionArray([...queue]);
                        }
                        
                        setFlashCell({ pos: p.pos, type: damageDealt ? 'damage' : 'attack_gray' });
                        logDetail = `Assault: ${hit1Msg}, ${hit2Msg}`.replace(/,\s*$/, "");
                    } else {
                        targets.forEach(target => {
                            if (target.isShielded) {
                                target.isShielded = false;
                                assaultDetails.push(`Blocked by ${getPlayerIcon(target.id)}`);
                            } else {
                                const oldHp = target.hp;
                                target.hp--; hits++;
                                assaultDetails.push(`Hit ${getPlayerIcon(target.id)} (HP ${oldHp}->${target.hp})`);
                                if (target.hp <= 0) {
                                    target.isDead = true; target.pos = [-1, -1]; 
                                    for (let k = i + 1; k < queue.length; k++) if (queue[k]?.playerId === target.id) { curEntities[target.id].discard.push(queue[k].card); queue[k] = null; }
                                    setActionArray([...queue]);
                                }
                            }
                        });
                        setFlashCell({ pos: p.pos, type: hits > 0 ? 'damage' : 'attack_gray' });
                        logDetail = `Assault: ${assaultDetails.join(", ")}`;
                    }

                } else if (effectiveType.includes('move')) {
                    const dirText = getDirectionText(p.pos, targetPos);
                    p.pos = targetPos;
                    logDetail = `Moved [${dirText}] from ${startPosStr} to ${endPosStr}`;
                }
            } else {
                logDetail = "Action Voided";
            }

            addLog(`${logPrefix} ${playerIcon} : ${logDetail}`);
            p.discard.push(action.card);
            
            if ((i + 1) % 4 === 0) {
                Object.values(curEntities).forEach(pl => pl.isShielded = false);
            }

            if (gameVersionRef.current !== currentRunVersion) return;

            setEntities({ ...curEntities }); setBoard([...curBoard]); setUnlockedCount(curUnlocked);
            
            await new Promise(r => setTimeout(r, FLASH_DURATION)); 
            
            if (gameVersionRef.current !== currentRunVersion) return; // Wait é†’ä¾†æª¢æŸ¥
            setFlashCell(null);
            
            await new Promise(r => setTimeout(r, 500));
            }

            Object.values(curEntities).forEach(p => {
            if (p.hand.length > 0) {
                p.discard.push(...p.hand);
                p.hand = [];
            }
            });
            
            if (gameVersionRef.current !== currentRunVersion) return; // çµç®—å‰æª¢æŸ¥
            setEntities({ ...curEntities });

            const wardIdx = WARD_PATH.findIndex(([pr, pc]) => pr === curWard[0] && pc === curWard[1]);
            const nextIdx = (wardIdx + 1) % WARD_PATH.length;
            setWardPos(WARD_PATH[nextIdx]);
            
            if (curUnlocked >= 3) {
                setWinner('AI Players'); // [Renamed]
            } 
            else if (curRounds - 1 <= 0) { 
                setWinner('User'); // [Renamed]
                setRemainingRounds(0); 
            } else { 
                setRemainingRounds(r => r - 1); 
                setGameTurn(t => t + 1); 
                startNewRound(curEntities, WARD_PATH[nextIdx], curBoard, curUnlocked, gameTurn + 1); 
            }
        };

        const finalizePlanning = () => { 
            // [Fix] é˜²æ­¢é€£é»ž
            if (gamePhase !== 'planning') return;

            const userRequired = entities.user.isRecovering ? 0 : 3; 
            const userInArray = actionArray.filter(a => a?.playerId === 'user' && a?.card).length; 
            if (userInArray < userRequired) return; 
            setActiveSelection(null); 
            
            const snapshot = {
                board: JSON.parse(JSON.stringify(board)),
                entities: JSON.parse(JSON.stringify(entities)), // [Renamed]
                wardPos: [...wardPos],
                unlockedCount,
                remainingRounds,
                gameTurn,
                actionArray: JSON.parse(JSON.stringify(actionArray)),
                logs: [...logs]
            };
            setCheckpoint(snapshot);
            
            setGamePhase('resolving'); 
            resolveActions(actionArray); 
        };
        
        const handleReturnToHand = () => { if (activeSelection?.type === 'array') { const newArray = [...actionArray]; const p = JSON.parse(JSON.stringify(entities)); p.user.hand.push(newArray[activeSelection.index].card); newArray[activeSelection.index] = null; setActionArray(newArray); setEntities(p); setActiveSelection(null); } };
        
        const handleItemClick = (type, index) => { 
            if (gamePhase !== 'planning') return; 
            if (type === 'hand') { 
            const isSelecting = !(activeSelection?.type === 'hand' && activeSelection.index === index); 
            setActiveSelection(isSelecting ? { type: 'hand', index } : null); 
            } else if (type === 'array' && index % 4 === 3) { 
            if (activeSelection) { 
                const newArray = [...actionArray]; 
                const p = JSON.parse(JSON.stringify(entities)); 
                if (activeSelection.type === 'hand') { 
                const card = p.user.hand[activeSelection.index]; 
                if (newArray[index]) p.user.hand.push(newArray[index].card); 
                newArray[index] = { playerId: 'user', card, visible: true }; 
                p.user.hand.splice(activeSelection.index, 1); 
                } 
                setActionArray(newArray); setEntities(p); setActiveSelection(null); 
            } else if (actionArray[index]) {
                setActiveSelection({ type: 'array', index }); 
            }
            }
        };

        const [installPrompt, setInstallPrompt] = useState(null);

        useEffect(() => {
            if ('serviceWorker' in navigator) {
                const registerSW = () => {
                    navigator.serviceWorker.register('./sw.js')
                        .then(registration => {
                            console.log('ServiceWorker registration successful:', registration.scope);
                        })
                        .catch(err => {
                            console.log('ServiceWorker registration failed:', err);
                        });
                };

                if (document.readyState === 'complete') {
                    registerSW();
                } else {
                    window.addEventListener('load', registerSW);
                }
            }

            const handleBeforeInstallPrompt = (e) => {
                e.preventDefault();
                setInstallPrompt(e);
            };

            window.addEventListener('beforeinstallprompt', handleBeforeInstallPrompt);

            return () => {
                window.removeEventListener('beforeinstallprompt', handleBeforeInstallPrompt);
            };
        }, []);

        const handleInstallClick = () => {
            if (!installPrompt) return;
            installPrompt.prompt();
            installPrompt.userChoice.then((choiceResult) => {
                if (choiceResult.outcome === 'accepted') {
                    console.log('User accepted the install prompt');
                }
                setInstallPrompt(null);
            });
        };

        return (
            <div id="app-container" className="min-h-screen bg-[#000000] text-[#d7ccc8] font-serif select-none flex flex-col items-center py-4 px-2">
            <CinematicAction effect={cinematicEffect} />
            
            {installPrompt && (
                <button 
                    onClick={handleInstallClick}
                    className="fixed bottom-4 right-4 z-50 bg-[#3e2723] text-[#d7ccc8] px-4 py-2 rounded-full border border-[#8d6e63] shadow-xl animate-bounce font-bold"
                >
                    â¬‡ï¸ å®‰è£ App
                </button>
            )}

            <div className="w-full max-w-[400px] flex flex-row items-stretch border-4 border-[#3e2723] rounded-3xl overflow-hidden shadow-2xl bg-[#000000] relative z-10">
                <div className="flex-1 flex flex-col border-r-2 border-[#3e2723]">
                <div id="board-container" className="p-3 bg-[#000000] relative">
                    <div className="grid grid-cols-3 gap-1.5 w-full aspect-square relative bg-[#000000] rounded-xl border border-[#3e2723] shadow-inner p-1">
                        {board.map((row, r) => row.map((cell, c) => (
                            <div key={`${r}-${c}`} id={`cell-${r}-${c}`} onClick={() => selectableCells.some(([sr, sc]) => sr === r && sc === c) && interactionResolverRef.current([r, c])} 
                            className={`w-full aspect-square rounded-lg border-2 flex flex-col items-center justify-center relative transition-all duration-300 overflow-hidden 
                            ${cell.type === 'lock' ? `bg-[#29201a] border-[#5d4037]` : cell.type === 'eye' ? `bg-[#392855] border-[${THEME_COLORS.BLUE}]` : 'bg-[#231e1b] border-[#443e3b]'} 
                            ${wardPos[0] === r && wardPos[1] === c ? `border-[${THEME_COLORS.PURPLE}] shadow-[inset_0_0_20px_rgba(106,13,173,0.3)]` : ''} 
                            ${selectableCells.some(([sr, sc]) => sr === r && sc === c) ? `cursor-pointer border-[${THEME_COLORS.GREEN}] bg-[${THEME_COLORS.GREEN}]/20 animate-pulse z-20 shadow-2xl` : ''} 
                            ${flashCell?.pos[0] === r && flashCell?.pos[1] === c ? (
                                        flashCell.type === 'damage' ? `bg-[${THEME_COLORS.RED}99] animate-shake` : 
                                        flashCell.type === 'unlock' ? `bg-[${THEME_COLORS.YELLOW}99] animate-pulse` :
                                        flashCell.type === 'heal_success' ? `bg-[${THEME_COLORS.GREEN}99]` :
                                        flashCell.type === 'shield' ? `bg-[${THEME_COLORS.BLUE}99]` :
                                        flashCell.type === 'attack_gray' ? `bg-[#6b728099]` :
                                    `bg-[${THEME_COLORS.YELLOW}]/40`
                                    ) : ''}`}>
                            
                            {flashCell?.pos[0] === r && flashCell?.pos[1] === c && flashCell.type === 'damage' && (
                                <>
                                    <div className="absolute inset-0 rounded-full border-2 border-white animate-ripple z-50"></div>
                                    <div className="absolute inset-0 rounded-full border-2 border-white animate-ripple z-50" style={{animationDelay: '0.15s'}}></div>
                                    <div className="absolute inset-0 rounded-full border-2 border-white animate-ripple z-50" style={{animationDelay: '0.3s'}}></div>
                                </>
                            )}

                            <div className="absolute top-1 right-1 flex items-center gap-1 z-[60]">
                                {cell.hourglass && <div className="animate-hourglass-glow"><Hourglass size={12} className={`text-[${THEME_COLORS.BLUE}]`} /></div>}
                                
                                {cell.type === 'lock' && cell.dice > 0 && (
                                    <div className="w-[18px] h-[18px] bg-[#d7ccc8] text-[#3e2723] rounded-[3px] flex items-center justify-center border border-[#8d6e63] shadow-sm">
                                        <span className="text-[10px] font-black leading-none">{cell.dice}</span>
                                    </div>
                                )}
                                
                                {cell.type === 'eye' && (
                                    <div className={`w-[18px] h-[18px] bg-[${THEME_COLORS.BLUE}66] border border-[${THEME_COLORS.BLUE}] rounded-[3px] flex items-center justify-center shadow-sm`}>
                                         <Eye size={10} className={`text-[${THEME_COLORS.BLUE}]`} />
                                    </div>
                                )}
                            </div>

                            <div className="absolute inset-0 flex items-center justify-center opacity-10 pointer-events-none p-4">
                                {cell.type === 'lock' && <Key size={20} className="text-[#8d6e63]" />}
                                {cell.type === 'eye' && (
                                (wardPos[0] === r && wardPos[1] === c) ? 
                                <Moon size={48} className="text-[#FFFFFF] drop-shadow-md" /> : 
                                <Eye size={48} className={`text-[${THEME_COLORS.BLUE}] animate-blink`} />
                                )}
                            </div>
                            
                            {wardPos[0] === r && wardPos[1] === c && (
                                <div className={`absolute top-1 left-1 w-[18px] h-[18px] bg-[${THEME_COLORS.PURPLE}66] border border-[${THEME_COLORS.PURPLE}] rounded-[3px] flex items-center justify-center shadow-[0_0_5px_rgba(106,13,173,0.5)] z-[60]`}>
                                    <Eye size={10} className={`text-[${THEME_COLORS.PURPLE}] animate-pulse`} />
                                </div>
                            )}

                            </div>
                        )))}
                        <TokenLayer entities={entities} />
                    </div>
                </div>

                <div className="px-3 py-1 bg-[#000000] border-b-2 border-[#3e2723] flex justify-between items-center shadow-lg relative z-10">
                    <div className="flex items-center gap-4">
                        <div className="flex gap-0.5">
                        {[...Array(Math.max(0, remainingRounds))].map((_, i) => (
                            <Moon key={i} size={12} className="text-[#FFFFFF] fill-[#FFFFFF]" />
                        ))}
                        </div>
                        <div className="flex gap-1.5">{[...Array(3)].map((_, i) => (<Key key={i} size={12} className={i < unlockedCount ? `text-[${THEME_COLORS.GOLD}] fill-[${THEME_COLORS.GOLD}]` : "text-[#4e342e]"} />))}</div>
                    </div>
                    <button onClick={() => setIsLogExpanded(!isLogExpanded)} className="p-1 bg-[#1a120b] border border-[#5d4037] rounded transition-colors hover:border-[#ffa000]"><List size={12}/></button>
                </div>
                <div className="px-2 py-2 flex gap-1 bg-[#000000] border-b-2 border-[#3e2723]">{Object.values(entities).map(p => <MiniStatus key={p.id} player={p} onClick={setViewingDiscard} />)}</div>
                
                <div className="h-[140px] p-2 bg-[#000000] relative shadow-inner">
                    {winner ? (
                        <div className="absolute inset-0 z-50 flex flex-col items-center justify-center bg-[#f5f5dc] animate-in zoom-in duration-500" style={{ backgroundImage: "url('https://www.transparenttextures.com/patterns/lined-paper-2.png')" }}>
                        <h2 className={`text-3xl font-black italic tracking-tighter uppercase font-serif drop-shadow-md ${winner === 'User' ? 'text-[#6a0dad]' : 'text-[#e53935]'}`}>
                            {winner === 'User' ? 'VICTORY' : 'DEFEAT'}
                        </h2>
                        <button onClick={handleSoftReset} className="mt-2 px-4 py-1 bg-[#3e2723] text-[#d7ccc8] rounded border border-[#8d6e63] text-[10px] font-bold uppercase hover:bg-[#5d4037] transition-colors">
                            New Game
                        </button>
                        </div>
                    ) : (
                        <div className={`grid grid-cols-5 gap-1.5 h-full mt-1 transition-all duration-500 ${gamePhase === 'resolving' ? 'opacity-40 grayscale pointer-events-none' : ''}`}>
                        {entities.user.hand.map((card, i) => (
                            <div key={i} onClick={() => handleItemClick('hand', i)} 
                            className={`h-full rounded border bg-[#f5f5dc] border-[#a1887f] text-[#3e2723] flex flex-col items-center justify-between py-1.5 transition-all shadow-md cursor-pointer relative ${activeSelection?.type === 'hand' && activeSelection.index === i ? 'scale-105 z-10 animate-border-flash' : 'hover:-translate-y-0.5'}`}
                            style={{ backgroundImage: "url('https://www.transparenttextures.com/patterns/cream-paper.png')", boxShadow: 'inset 0 0 10px rgba(161, 136, 127, 0.2), 2px 2px 5px rgba(0,0,0,0.3)' }}
                            >
                            <span className="text-[6px] font-black uppercase text-[#3e2723] text-center leading-[1.1] px-0.5 border-b border-[#d7ccc8] pb-0.5 w-full">{card.name}</span><div className="flex-grow flex items-center justify-center opacity-80 scale-125"><ActionIcons type={card.type} size={16} dark={true} /></div><div className="w-[80%] h-0.5 bg-[#8d6e63] mt-1 opacity-30 rounded-full" />
                            </div>
                        ))}
                        </div>
                    )}
                    
                    {!winner && gamePhase === 'planning' && actionArray.filter(a => a?.playerId === 'user' && a?.card).length === 3 && <button onClick={finalizePlanning} className={`absolute top-1 right-2 w-8 h-8 bg-[${THEME_COLORS.GREEN}] text-white rounded-full shadow-lg flex items-center justify-center animate-bounce border-2 border-white z-20 transition-all hover:brightness-110`}><Check size={16} strokeWidth={4} /></button>}
                    {!winner && activeSelection?.type === 'array' && <button onClick={handleReturnToHand} className="absolute top-1 left-2 w-8 h-8 bg-[#4e342e] text-[#d7ccc8] rounded-full flex items-center justify-center border-2 border-[#8d6e63] z-20 animate-pulse shadow-xl"><RotateCcw size={14}/></button>}
                    
                    {isLogExpanded && <div className="absolute inset-0 bg-[#f5f5dc] z-30 p-2 animate-in slide-in-from-bottom duration-300" style={{ backgroundImage: "url('https://www.transparenttextures.com/patterns/lined-paper-2.png')" }}>
                        <div className="relative flex justify-between items-center mb-1 border-b border-[#8d6e63] pb-1">
                        <span className="text-[10px] font-black uppercase text-[#3e2723]">Battle Log</span>
                        <button 
                            onClick={() => confirmNewGame ? handleSoftReset() : setConfirmNewGame(true)} 
                            className={`absolute left-1/2 -translate-x-1/2 px-2 py-0.5 text-[8px] rounded font-bold transition-all ${confirmNewGame ? 'bg-[#b71c1c] text-white scale-110' : 'bg-[#3e2723] text-white hover:bg-[#5d4037]'}`}
                        >
                            {confirmNewGame ? "SURE?" : "NEW GAME"}
                        </button>
                        <X size={14} onClick={() => { setIsLogExpanded(false); setConfirmNewGame(false); }} className="text-[#5d4037] cursor-pointer"/>
                        </div>
                        <div className="h-[105px] overflow-y-auto font-serif text-[9px] space-y-1 text-[#3e2723] leading-relaxed custom-scrollbar">{logs.map((l, i) => <div key={i} className="border-b border-[#8d6e63]/20 pb-0.5">{String(l)}</div>)}</div>
                    </div>}

                    {viewingDiscard && <div className="absolute inset-0 bg-[#f5f5dc] z-30 p-2 animate-in slide-in-from-bottom duration-300" style={{ backgroundImage: "url('https://www.transparenttextures.com/patterns/lined-paper-2.png')" }}>
                        <div className="flex justify-between items-center mb-1 border-b border-[#8d6e63] pb-1"><h3 className="text-[10px] font-black text-[#3e2723] uppercase tracking-widest flex items-center gap-1"><span className="text-[12px]">{getPlayerIcon(viewingDiscard.id)}</span> DISCARD</h3><X size={14} onClick={() => setViewingDiscard(null)} className="text-[#5d4037] cursor-pointer"/></div>
                        <div className="h-[105px] overflow-y-auto text-[9px] space-y-1 uppercase font-bold text-[#5d4037] tracking-tighter custom-scrollbar">{viewingDiscard.discard.length === 0 ? <p className="italic opacity-30 text-center py-4">Empty</p> : viewingDiscard.discard.map((card, idx) => (<div key={idx} className="flex justify-between items-center border-b border-[#8d6e63]/20 py-0.5"><span>{card.name}</span><ActionIcons type={card.type} size={10} dark={true} /></div>))}</div>
                    </div>}
                </div>
                </div>

                <div className="w-[85px] flex flex-col bg-[#000000] shadow-2xl relative border-l-2 border-[#3e2723]">
                <div className="flex-grow flex flex-col p-1 gap-1 bg-[#000000] h-full overflow-hidden">
                    {actionArray.map((action, i) => {
                        const isUserSlot = i % 4 === 3;
                        const isActive = resolvingIndex === i;
                        const isPlacementTarget = activeSelection?.type === 'hand' && isUserSlot && gamePhase === 'planning';
                        const getHardCodedPlayerBorder = (color) => { if (color === 'red') return THEME_COLORS.RED; if (color === 'yellow') return THEME_COLORS.YELLOW; if (color === 'green') return THEME_COLORS.GREEN; if (color === 'purple') return THEME_COLORS.PURPLE; return '#3e2723'; };
                        const isRevealed = action && (action.visible || resolvingIndex >= i);
                        const isResolved = resolvingIndex > i;

                        return (
                        <div key={i} id={`slot-${i}`} onClick={() => isUserSlot && handleItemClick('array', i)} 
                            className={`flex-1 min-h-0 w-full rounded border-4 flex flex-col items-center justify-center relative transition-all 
                            ${action ? 'bg-[#f5f5dc]' : (isUserSlot ? `border-dashed border-[${THEME_COLORS.PURPLE}4d]` : 'border-dashed border-[#3e2723]')} 
                            ${isActive ? 'ring-4 ring-[#f59e0b] shadow-[0_0_20px_#f59e0b] brightness-110 z-20' : ''}
                            ${isResolved ? 'opacity-50 grayscale' : ''}
                            ${isPlacementTarget ? `animate-border-flash bg-[${THEME_COLORS.PURPLE}1a] cursor-pointer` : ''}
                            `}
                            style={action ? { borderColor: getHardCodedPlayerBorder(entities[action.playerId].color), backgroundImage: "url('https://www.transparenttextures.com/patterns/cream-paper.png')", boxShadow: 'inset 0 0 5px rgba(0,0,0,0.2)' } : {}}
                        >
                            {action && isRevealed && <ActionIcons type={action.card.type} size={14} dark={true} />}
                            {!action && <span className="text-[7px] opacity-10 uppercase tracking-tighter font-mono">{isUserSlot ? 'USER' : i+1}</span>}
                            {isResolved && action && <div className="absolute inset-0 flex items-center justify-center bg-[#0000001a] rounded"><Check size={24} className={`text-[${THEME_COLORS.GREEN}] font-bold drop-shadow-md`} /></div>}
                            {i % 4 === 0 && <div className="absolute left-[-15px] top-1/2 -translate-y-1/2 text-[5px] text-[#8d6e63] font-bold transform -rotate-90">M{Math.floor(i/4)+1}</div>}
                        </div>
                        );
                    })}
                </div>
                </div>
            </div>

            <style dangerouslySetInnerHTML={{ __html: `
                @keyframes fly { 
                0% { left: var(--start-x); top: var(--start-y); transform: translate(-50%, -50%) scale(0); opacity: 0; }
                15% { left: var(--center-x); top: var(--center-y); transform: translate(-50%, -50%) scale(1.5); opacity: 1; }
                55% { left: var(--center-x); top: var(--center-y); transform: translate(-50%, -50%) scale(1.5); opacity: 1; }
                100% { left: var(--end-x); top: var(--end-y); transform: translate(-50%, -50%) scale(0.3); opacity: 0; }
                }
                @keyframes border-flash { 
                0%, 100% { border-color: #6a0dad; box-shadow: inset 0 0 10px #6a0dad; } /* [ä¿®æ”¹] å…§ç™¼å…‰ */
                50% { border-color: #ffffff; box-shadow: inset 0 0 20px #ffffff; } 
                }
                
                @keyframes eye-blink {
                0%, 48%, 52%, 100% { transform: scaleY(1); }
                50% { transform: scaleY(0.1); }
                }

                @keyframes ripple-effect {
                0% { transform: scale(0.5); opacity: 1; border-width: 2px; }
                100% { transform: scale(2.0); opacity: 0; border-width: 0px; }
                }

                .animate-cinematic-fly { animation: fly 2s cubic-bezier(0.25, 1, 0.3, 1) forwards; position: fixed; }
                .animate-border-flash { animation: border-flash 3s infinite; }
                .animate-blink { animation: eye-blink 12s infinite; }
                .animate-ripple { animation: ripple-effect 0.5s ease-out forwards; }
                
                @keyframes shake { 0%, 100% { transform: translateX(0); } 20% { transform: translateX(-3px); } 60% { transform: translateX(3px); } }
                @keyframes hourglass-glow { 0%, 100% { opacity: 0.8; transform: scale(1) rotate(0deg); } 50% { opacity: 1; transform: scale(1.3) rotate(180deg); } }
                .animate-hourglass-glow { animation: hourglass-glow 3s ease-in-out infinite; }
                .animate-shake { animation: shake 0.1s ease-in-out infinite; }
                .custom-scrollbar::-webkit-scrollbar { width: 3px; }
                .custom-scrollbar::-webkit-scrollbar-thumb { background: #8d6e63; border-radius: 10px; }
            `}} />
            </div>
        );
        }

        const root = ReactDOM.createRoot(document.getElementById('root'));
        root.render(<App />);
    </script>
</body>
</html>
